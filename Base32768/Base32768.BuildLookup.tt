<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
(int numZBits, char z)[] lookupD = new (int numZBits, char z)[0xA860];
char[] lookupE7 = Build(new (char from, char to)[] {
    ('\u0180', '\u01a0'), ('\u0240', '\u02a0'),
}, 128, 1);
char[] lookupE15 = Build(new (char from, char to)[] {
    ('\u04a0', '\u04c0'), ('\u0500', '\u0520'), ('\u0680', '\u06c0'), ('\u0760', '\u07a0'),
    ('\u07c0', '\u07e0'), ('\u1000', '\u1020'), ('\u10a0', '\u10c0'), ('\u1100', '\u1160'),
    ('\u1180', '\u11a0'), ('\u11e0', '\u1240'), ('\u1260', '\u1280'), ('\u12e0', '\u1300'),
    ('\u1320', '\u1340'), ('\u13a0', '\u13e0'), ('\u1420', '\u1660'), ('\u16a0', '\u16e0'),
    ('\u1780', '\u17a0'), ('\u1820', '\u1860'), ('\u18c0', '\u18e0'), ('\u1980', '\u19a0'),
    ('\u19e0', '\u1a00'), ('\u1a20', '\u1a40'), ('\u1bc0', '\u1be0'), ('\u1c00', '\u1c20'),
    ('\u1d00', '\u1d20'), ('\u21e0', '\u2200'), ('\u22c0', '\u22e0'), ('\u2340', '\u23e0'),
    ('\u2400', '\u2420'), ('\u2500', '\u2760'), ('\u2780', '\u27c0'), ('\u2800', '\u2980'),
    ('\u29a0', '\u29c0'), ('\u2a20', '\u2a60'), ('\u2a80', '\u2ac0'), ('\u2ae0', '\u2b60'),
    ('\u2c00', '\u2c20'), ('\u2c80', '\u2ce0'), ('\u2d00', '\u2d20'), ('\u2d40', '\u2d60'),
    ('\u2ea0', '\u2ee0'), ('\u31c0', '\u31e0'), ('\u3400', '\u4da0'), ('\u4dc0', '\u9fc0'),
    ('\ua000', '\ua480'), ('\ua4a0', '\ua4c0'), ('\ua500', '\ua600'), ('\ua640', '\ua660'),
    ('\ua6a0', '\ua6e0'), ('\ua700', '\ua760'), ('\ua780', '\ua7a0'), ('\ua840', '\ua860'),
}, 32768, 0);
char[] Build((char from, char to)[] pairString, int size, int r)
{
    var numZBits = new int[2]{15,7}[r];
    var encodeRepertoire = new char[size];
    var ix = 0;
    foreach (var (from, to) in pairString)
        for (char i = from; i < to; i++)
        {
            lookupD[i] = (numZBits, (char)ix);
            encodeRepertoire[ix++] = i;
        }
    System.Diagnostics.Debug.Assert(size == ix);
    return encodeRepertoire;
}
string CharLiteral(int c) => $"'\\u{c:X4}'";
string IntCharTupleLiteral((int numZBits, char z) tup)
{
    if (tup == default)
        return "default";
    else
        return $"({tup.numZBits}, {CharLiteral(tup.z)})";
}
#>

// <auto-generated>
// This code was generated by t4. Do not change the code manually.
// </auto-generated>

namespace Kzrnm.Convert.Base32768
{
    public static partial class Base32768
    {
        internal static readonly (int numZBits, char z)[] lookupD = new (int numZBits, char z)[0xA860]{
<# foreach(var tup in lookupD) { #>
<#= IntCharTupleLiteral(tup) #>,
<# } #>
        };
        internal static readonly char[] lookupE7 = new char[1 << 7]{
<# foreach(var c in lookupE7) { #>
<#= CharLiteral(c) #>,
<# } #>
        };
        internal static readonly char[] lookupE15 = new char[1 << 15]{
<# foreach(var c in lookupE15) { #>
<#= CharLiteral(c) #>,
<# } #>
        };
        private static char[] Build((char from, char to)[] pairString, int size, int r)
        {
            var numZBits = BITS_PER_CHAR - BITS_PER_BYTE * r;
            var encodeRepertoire = new char[size];
            var ix = 0;
            foreach (var (from, to) in pairString)
                for (char i = from; i < to; i++)
                {
                    lookupD[i] = (numZBits, (char)ix);
                    encodeRepertoire[ix++] = i;
                }
            System.Diagnostics.Debug.Assert(size == ix);
            return encodeRepertoire;
        }
    }
}